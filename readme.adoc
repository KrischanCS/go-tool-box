// If you read this, you view it somewhere where asciidoc is not supported
// (e.g. on pkg.go.dev).
//
// Github renders this file nicely, so you can view it there: github.com/KrischanCS/go-toolbox
//
// I stay with asciidoc for the moment, because this is a playground project for
// me anyway and I want to check it out as markdown alternative.

== Go Toolbox

This is a collection of packages, which I implemented out of one of the following reasons:

* I tend to implement parts of it in different projects, and wanted to have them in one place.
* I wanted to learn and/or play around with some concepts, which I find interesting.
* I wanted to compare different implementations of the same concept, e.g. iterators.

While there are unit tests for everything in this module, not all of this was ever used in production and I don't
guarantee to maintain any of this in the future. So I can't recommend to use this in your projects. Remember:

[quote,Rob Pike in his 'Go Proverbs' talk,https:go-proverbs.github.io]
--
A little copying is better than a little dependency.
--

=== Packages

Currently, the tool box contains the following packages, more may follow.

If some of them turns out specifically useful, they may be moved to their own modules.

==== Set

Set provides an implementation of a set, meaning a collection of unique, unordered values.

It implements basic collection options as add, remove, contains, len and clear as well as common set operations like union, intersection and difference.

==== Must

Must provides functions which panics on error and returns the value(s) passed to them.

This is usually not recommended, but can be helpful in tests or initialization of an application.

It can be used like regex.MustCompile or template.MustParse but for arbitrary functions (With two or three return parameters).

==== Result

Result a type wrapping either a value or an error.
It is inspired by usts result type, but tries to remain as idiomatic to go as possible

Main use case is to send it over channels, when possible errors should be propagated to the receiver.

Apart from that, after calling `Get()`, it can be used with go's idiomatic error handling, like:

[source,go]
--
value, err := result.Get()
if err != nil {
  handle error
}
--

==== Pool

Pool provides a convenient way to create a worker pools

==== Optional

Optional provides a generic Optional type for Go.

For a lot of use cases, I don't like mixing the concepts of referencing and optionality, as it happens with pointers, so this provides an alternative.

The Optionals implemented in this package handle marshalling and unmarshalling to/from json and xml and are handling null-values, not existing values and omitzero/omitempty.

==== Iterator

Iterator implements a handful of different iterators. currently this is mainly for playing around and getting to know the characteristics of the go iterators, which are part of the language since go 1.23 (when writing this, go 1.24 is the recent version, so they are still quite new).

In the tests of this package some benchmarks are included, which compare the performance of the different iterators with equivalent implementations using normal for-loops.
Executing those can be seen that the iterators add some overhead (on my machine roughly 2-4 ns slower per loop execution than a standard for loop), so in performance critical code they should probably be avoided for tight loops.
If more significant work is done in the loop body, the overhead becomes more negligible.

On the other hand the iterators can improve readability and clarity in some cases in my opinion, e.g. the `Zip` or
`Filter`

.Filter with iterator.
[source, go]
----
res := 0
for v := range iterator.Filter(iterator, divisibleByThree) {
	res += v*3 - 1
	if v == breakAt {
		break
	}
}
----

.Filter with for-loop.
[source, go]
----
res := 0
for i := from; i < to; i++ {
	if !divisibleByThree(i) {
		continue
	}

	res += i*3 - 1
	if i == breakAt {
		break
	}
}
----

.Zip with iterator.
[source, go]
----
intRes := 0
strRes := ""
for pair := range iterator.Zip(iterator1, iterator2) {
	intRes += pair.Left*3 - 1
	strRes += pair.Right
	if pair.Left == breakAt {
		break
	}
}
----

.Zip with for-loop.
[source, go]
----
intRes := 0
strRes := ""

for i, v := range slice1 {
	if i > len(slice2)-1 {
		break
	}

	intRes += v*3 - 1
	strRes += slice2[i]

	if v == breakAt {
		break
	}
}
----

